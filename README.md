# Тестовое задание на позицию middle python backend developer

Необходимо создать микросервис, который может быть запущен в N репликах, где N∈(0, 16], 
каждая из реплик при старте должна соединяться с свободной (то есть той, к которой не 
подключены другие реплики) базой Redis, и далее уже работать только с ней. К базам других 
реплик каждая из них доступа иметь **не должна**. То есть persistent storage каждой реплики 
должны быть изолированными (в плане доступа к данным) друг от друга.

Количество реплик при старте приложения определяется администратором при запуске 
(docker-compose через `deploy.replicas`, k8s через `Deployment.spec.replicas`, итд).

При этом инстанс Redis нужно запускать один, данные авторизации (хост, порт, пароль), 
разумеется, также идентичны для всех реплик. Максимальное количество баз данных в настройках 
должно быть равно значению по умолчанию (16шт), см https://redis.io/docs/management/config-file/
`databases 16`.

Каждая реплика сервиса при первом старте получает какой-то класс, это просто переменная, обозначающая 
тип сервиса,  но для текущей задачи никак не влияющая на логику вычислений внутри.
Класс может хранится в БД (если БД уже была инициализирована какой-то репликой ранее) и реплика после 
коннекта к БД может "подхватывать" тот класс, который был записан в базе при повторном запуске. 
Идентификатор класса представляет собой одну из букв из списка: `['A', 'B', 'C', 'D']`, соотвественно, несколько 
реплик могут иметь одинаковый класс, также как и группа реплик может не иметь одного или нескольких классов.   

Сервис должен реализовать 3 API эндпойнта:

### Первый эндпойнт - получение классов
> GET /classes

Отдаёт список классов, которые реализованы в репликах на сервере. 

Ответ должен быть таким (Pydantic):
```python
from typing import Literal
from pydantic import RootModel

ClassesList = RootModel[list[Literal['A', 'B', 'C', 'D']]]
```

Пример (у нас есть 4 реплики, 3 с классом `A` и одна с классом `C`):
```json
["A", "C"]
```

### Второй эндпойнт - запись значения 
> POST /values

Схема запроса (Pydantic):

```python
from pydantic import BaseModel, RootModel
from typing import Literal

class CreateValueEntity(BaseModel):
    value: int
    ttl: int
    cls: Literal['A', 'B', 'C', 'D']

CreateValuesRequest = RootModel[list[CreateValueEntity]]
```

При получении этого запроса сервис должен разложить каждое из пришедших чисел на простые множители и сохранить результат
в базе Redis той реплики, которая соответствует запрошенному классу. При этом время жизни значения должно 
составлять `ttl` (в секундах). Если передан неверный класс, должна отображаться ошибка валидации (400 или 422).
Если передан класс, который не реализован в группе реплик, отдавать 404 с произвольным текстом. 
Формат тела ошибки на Ваше усмотрение.

При повторном запросе числа `value` с одинаковым `cls` логика такая:
- `ttl` обновляется на новый для данных во всех репликах

Если же значение `value` уже есть в базе, но класс другой, просто считаем заново. То есть, происходит полная 
перезапись, а не дополнение.

Сервер должен отдать такие данные (список простых множителей числа):

```python
from pydantic import RootModel, BaseModel

class CalculatedValueEntity(BaseModel):
    value: int
    prime_factors: list[int]

SetValueResponse = RootModel[list[CalculatedValueEntity]]
```

Пример:

> POST /values [{"value": 144, "ttl": 300, "cls": "A"}, {"value": 120, "ttl": 600, "cls": "C"}] 
>
> 200 OK [{"value": 144, "prime_factors": [2, 2, 2, 2, 3, 3]}, {"value": 120, "prime_factors": [2, 2, 2, 3, 5]}]

### Третий эндпойнт - получение значений
> GET /values/{prime_factor:int}

Запрос должен вернуть список из всех значений на сервере, для которых число `prime_factor` является множителем.
Если число `prime_factor` не простое - можно сразу выдавать ошибку 400 или 422 в свободной форме, либо вернуть
пустой ответ (на Ваше усмотрение).

Тело запроса пустое, ответ сервера аналогичен ответу на предыдущий запрос (см. выше):

```python
from pydantic import RootModel, BaseModel

class CalculatedValueEntity(BaseModel):
    value: int
    prime_factors: list[int]

SetValueResponse = RootModel[list[CalculatedValueEntity]]
```

Пример:

> GET /values/5
> 
> 200 OK [{"value": 120, "prime_factors": [2, 2, 2, 3, 5]}]

## Требования
- Язык python3, ОС 64-битная, Arch amd64 или arm64
- Использование любого асинхронного фреймворка (fastapi, aiohttp, litestar, starlette, etc)
- Сборка приложения в Docker-контейнер
- Запуск в docker-compose (предпочтительно) или swarm/k8s (если есть время), возможно использование 
других типов оркестраторов, но в этом случае нехобходимо предоставить инструкцию по развёртыванию. 
- Использование Redis 6.0+
- Вся конфигурация приложения должна задаваться через переменные среды
- Код должен быть опубликован на git-репозитории с доступом для проверки 

Будет плюсом:
- Использование load-balancer'а
- Использование MQ



