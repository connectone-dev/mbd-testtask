# Тестовое задание на позицию middle python backend developer

Необходимо создать микросервис, который может быть запущен в N репликах, где N∈(0, 16], 
каждая из реплик при старте должна соединяться с свободной (то есть той, к которой не 
подключены другие реплики) базой Redis, и далее уже работать только с ней. К базам других 
реплик каждая из них доступа иметь **не должна**. То есть persistent storage каждой реплики 
должны быть изолированными (в плане доступа к данным) друг от друга.

Реплика может подключаться при старте кратковременно к базе `0`, то только для чтения каких-то
служебных данных на фазе инициализации, читать значения бизнес-логики (о них ниже) репликам 
из "чужих" баз запрещено.

Количество реплик при старте приложения определяется администратором при запуске 
(docker-compose через `deploy.replicas`, k8s через `Deployment.spec.replicas`, итд). Сервис должен 
нормально обрабатывать scaling.

При этом инстанс Redis нужно запускать один, данные авторизации (хост, порт, пароль), 
разумеется, также идентичны для всех реплик. Максимальное количество баз данных в настройках 
должно быть равно значению по умолчанию (16шт), см https://redis.io/docs/management/config-file/
`databases 16`.

Сервис должен реализовать 2 API эндпойнта (REST-like):

### Первый эндпойнт - запись значения 
> POST /values?ttl={ttl:int}

Схема запроса (Pydantic):

```python
from pydantic import RootModel

CreateValuesRequest = RootModel[list[int]]
```

При получении этого запроса сервис должен разложить каждое из пришедших чисел (из массива) на простые множители и 
сохранить результат в базе Redis той реплики, которая соответствует запрошенному классу. При этом время жизни значения 
должно составлять `ttl` (в секундах), если указано в query parameter, если не указано, то `ttl=infinity`. Если 
какие-то из полей имеют неверный формат, нужно отдавать код 400 или 422. Формат тела ошибки на Ваше усмотрение.

Если в базе содержится уже какое-то (какие-то) из чисел, пришедших в запросе, то нужно для всех обновить `ttl` (во всех
репликах).

Сервер должен отдать такие данные (список простых множителей числа):

```python
from pydantic import RootModel, BaseModel

class CalculatedValueEntity(BaseModel):
    value: int
    prime_factors: list[int]

SetValueResponse = RootModel[list[CalculatedValueEntity]]
```

Пример:

> POST /values?ttl=300 [144, 120] 
>
> 200 OK [{"value": 144, "prime_factors": [2, 2, 2, 2, 3, 3]}, {"value": 120, "prime_factors": [2, 2, 2, 3, 5]}]

### Второй эндпойнт - получение значений
> GET /values/{prime_factor:int}

Запрос должен вернуть список из всех значений на сервере, для которых число `prime_factor` является множителем.
Если число `prime_factor` не простое - можно сразу выдавать ошибку 400 или 422 в свободной форме, либо вернуть
пустой ответ (на Ваше усмотрение).

Тело запроса пустое, ответ сервера аналогичен ответу на предыдущий запрос (см. выше):

```python
from pydantic import RootModel, BaseModel

class CalculatedValueEntity(BaseModel):
    value: int
    prime_factors: list[int]

SetValueResponse = RootModel[list[CalculatedValueEntity]]
```

Пример:

> GET /values/5
> 
> 200 OK [{"value": 120, "prime_factors": [2, 2, 2, 3, 5]}]

## Требования

Требования к коду:
- Язык python3, ОС 64-битная, Arch amd64 или arm64
- Использование любого асинхронного фреймворка (fastapi, aiohttp, litestar, starlette, etc)
- Сборка приложения в Docker-контейнер
- Запуск в docker-compose (предпочтительно) или swarm/k8s (если есть время), возможно использование 
других типов оркестраторов, но в этом случае нехобходимо предоставить инструкцию по развёртыванию. 
- Использование Redis 6.0+
- Вся конфигурация приложения должна задаваться через переменные среды
- Код должен быть опубликован на git-репозитории с доступом для проверки 

Прочие требования:
- Сама математика оцениваться будет с низким приоритетом, реализовывать функцию факторизации с нуля необязательно, 
можно взять из публичного пакета, на Ваш выбор.

Будет плюсом:
- Использование load-balancer'а
- Использование MQ



